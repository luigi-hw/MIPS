// Test program for MIPS processor
// All instructions implemented in decoder_mips.v
// Format: 32-bit hex instruction per line

// Initialize registers first with ADDI (loads from $0 which is always 0)
// ADDI $1, $0, 5       -> $1 = 5
20010005
// ADDI $2, $0, 10      -> $2 = 10  
2002000a
// ADDI $3, $0, 15      -> $3 = 15
2003000f
// ADDI $4, $0, -1      -> $4 = -1 (0xFFFFFFFF)
2004ffff

// ============ R-TYPE INSTRUCTIONS ============
// ADD $5, $1, $2       -> $5 = 5+10 = 15 (opcode=0, funct=32)
00222820
// ADDU $6, $1, $2      -> $6 = 15 (opcode=0, funct=33)
00223021
// SUB $7, $2, $1       -> $7 = 10-5 = 5 (opcode=0, funct=34)
00413822
// SUBU $8, $3, $1      -> $8 = 15-5 = 10 (opcode=0, funct=35)
00614023
// AND $9, $1, $2       -> $9 = 5 & 10 = 0 (opcode=0, funct=36)
00224824
// OR $10, $1, $2       -> $10 = 5 | 10 = 15 (opcode=0, funct=37)
00225025
// XOR $11, $1, $2      -> $11 = 5 ^ 10 = 15 (opcode=0, funct=38)
00225826
// NOR $12, $1, $2      -> $12 = ~(5|10) (opcode=0, funct=39)
00226027

// ============ I-TYPE ALU INSTRUCTIONS ============
// ADDIU $13, $1, 100   -> $13 = 5+100 = 105 (opcode=9)
242D0064
// ANDI $14, $2, 0x0F   -> $14 = 10 & 15 = 10 (opcode=12)
304E000F
// ORI $15, $2, 0xF0    -> $15 = 10 | 240 = 250 (opcode=13)
344F00F0
// XORI $16, $2, 0xFF   -> $16 = 10 ^ 255 = 245 (opcode=14)
385000FF
// LUI $17, 0x1234      -> $17 = 0x12340000 (opcode=15)
3c111234
// SLTI $18, $1, 10     -> $18 = (5 < 10) ? 1 : 0 = 1 (opcode=10)
2832000A
// SLTIU $19, $2, 5     -> $19 = (10 < 5) ? 1 : 0 = 0 (opcode=11)
2C530005

// ============ MEMORY INSTRUCTIONS ============
// SW $1, 0($0)         -> mem[0] = 5 (opcode=43)
ac010000
// SW $2, 4($0)         -> mem[4] = 10 (opcode=43)
ac020004
// LW $20, 0($0)        -> $20 = mem[0] = 5 (opcode=35)
8c140000
// LW $21, 4($0)        -> $21 = mem[4] = 10 (opcode=35)
8c150004

// ============ BRANCH INSTRUCTIONS ============
// BEQ $1, $1, +2       -> branch taken (skip next 2) (opcode=4)
10210002
// ADDI $22, $0, 99     -> SKIPPED if BEQ works
20160063
// ADDI $22, $0, 88     -> SKIPPED if BEQ works  
20160058
// ADDI $22, $0, 1      -> $22 = 1 (executed after branch)
20160001
// BNE $1, $2, +1       -> branch taken (1 != 2) (opcode=5)
14220001
// ADDI $23, $0, 99     -> SKIPPED if BNE works
20170063
// ADDI $23, $0, 2      -> $23 = 2 (executed)
20170002

// NOP (filler)
00000000
2018FFFE
07000001
20190063
20190001
201A0002
07410001
201B0063
201B0002
201C002D
03800008
201D007B
201D0007
00000000
00000000
201D0007
201E0030
03C00009
201F0063
201F0001
0022C02A
0041C82B
00000000
// ============ NEW: Immediate shifts and JAL tests ============
// SLL $6, $5, 1       -> $6 = $5 << 1 = 30
00053040
// SRL $6, $5, 1       -> $6 = $5 >> 1 = 7
00053042
// SRA $6, $5, 1       -> $6 = $5 >>> 1 = 7 (since $5=15 is positive)
00053043
// JAL to 60           -> $31 = link (PC+1), PC = 60
0C000078
// filler NOPs
00000000
00000000
00000000
// Target 120:
// ensure some activity at target (ADDI $30, $0, 3)
201E0003
